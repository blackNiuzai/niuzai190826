## redis 锁

redis有3种部署方式：

单机模式

master-slave + sentinel选举模式

redis cluster模式

使用redis做分布式锁的缺点在于：如果采用单机部署模式，会存在单点问题，只要redis故障了。加锁就不行了。

采用master-slave模式，加锁的时候只对一个节点加锁，即便通过sentinel做了高可用，但是如果master节点故障了，发生主从切换，此时就会有可能出现锁丢失的问题。

基于以上的考虑，其实redis的作者也考虑到这个问题，他提出了一个RedLock的算法，这个算法的意思大概是这样的：

假设redis的部署模式是redis cluster，总共有5个master节点，通过以下步骤获取一把锁：

获取当前时间戳，单位是毫秒

轮流尝试在每个master节点上创建锁，过期时间设置较短，一般就几十毫秒

尝试在大多数节点上建立一个锁，比如5个节点就要求是3个节点（n / 2 +1）

客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了

要是锁建立失败了，那么就依次删除这个锁

只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁

## 对于zk分布式锁而言:

zookeeper天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。

如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。


### redisson解决了什么问题
使锁可重入
使锁可以续命
实现了阻塞锁，使得业务上可以使用可以等待
删锁及续命等操作使用了lua脚本来保证其原子操作

### redis cluster
主要可以解决海量存储的问题
公司使用的是codis，也是一种分布式方案
区别： codis使用代理去做的分布式，redis-cluster是去中心化的， 由客户端指定去哪个server进行读写

### zset
底层是跳表和散列表，跳表就是升级版的链表，通过添加各级索引加快搜索速度
一般来说用分数范围查询时使用跳表， 用key查询时使用散列表

### 数据一致性问题
先更新表再删除缓存也仍然有几率发生缓存放了旧数据，
所以更保险的做法是再结合mq等做日志补偿。


### redis单线程的问题
redis6.0以前一个redis只能用到cpu的一核，官方认为如果想榨干cpu性能可以开多个redis

随着网络硬件性能的提升，redis的性能瓶颈可能出现在了网络io上，所以redis6.0对于网络io采用多线程处理，
在命令的执行上仍然采用单线程

####redis如果内存满了
看配置策略，如果有淘汰策略并且淘汰了数据就可以继续用，如果没有那就宕机

#### redis的事务
属于弱事务，如果在命令入队阶段能检测到，那么就整个队伍的命令都不执行（语法错误啥的）
如果在执行时候才报错，那已经执行的命令不会回滚，（类型不匹配啥的），也不会导致后续的命令不做


