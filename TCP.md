#### 四次挥手
FIN_WAIT1是主动断开连接方发出关闭请求后的状态，表示主动方(主动断开TCP连接的一方)已经没有信息要发送给被动方

CLOSED_WAIT是被动方接收到主动方的关闭请求后返回ACK响应后的状态，此时被动方应该做的是查看自身是否还有数据需要传递给主动方，如果没有则发送关闭请求

FIN_WAIT2是主动方向被动方发送关闭请求后接收到响应后的状态

LAST_ACK是被动方已经确定没有数据需要传递给主动方后，发送给主动方关闭请求后的状态，表示最后一次响应主动方，它最后再等待主动方的ACK报文，当收到报文后便CLOSED

WAIT_TIME是主动方接收到被动方关闭请求后的状态，它再返回响应给被动方，被动方收到这个响应后便断开连接。此时主动方再等待2MSL，来确保被动方已经没有信息传递给主动方了，时间过后则关闭连接


#####为什么等待2MSL

1、在主动方发送出最后的ACK回复，但该ACK可能丢失。被动方如果没有收到ACK，
将不断重复发送FIN片段。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。
如果直到2MSL，主动方都没有再次收到FIN，那么主动方推断ACK已经被成功接收，确保被动方已经断开连接，
则结束此次TCP连接。

2、等待2MSL就可以使本连接持续的时间所产生的所有报文段都从网络中消失。
这样就可以使下一个新的连接中不会出现这种旧的连接请求的报文段。


##### tcp存在粘包现象
http用回车符、换行符作为http header边界，用content length作为http body的边界来解决


####https
https需要先完成tcp建立连接， 然后走tls握手过程；
tls握手过程中先在非加密情况下交换随机数和沟通加密算法，服务端还会发送自己的证书给客户端
客户端获得证书后验证证书没问题后， 会再生成一个随机数，这个随机数用证书里的公钥加密传给服务端
届时服务端客户端都同时持有三个随机数，其中最后一个是只有他们双方知道，接下来用最开始沟通的加密算法加密一下，生成本次通话后续对称加密要用的会话密钥

### http各版本
http1.1：使用了长连接，发送不阻塞，但是响应队头阻塞
http2  ：长连接+多路复用解决了http层面应用层面的响应队头阻塞，但因为是面向字节流的（tcp层需要确保数据是完整连续才会返回给http层，如果tcp丢包，所有http都会阻塞）

### tcp控制位
ACK 确认应答
RST 连接中出现异常必须强制断开连接
SYN 表示希望建立连接
FIN 表示今后不在会有数据，希望断开连接


####四次挥手
被动关闭方在收到fin时候可以理解回复ack，等自己数据发送完（因为此时被动关闭方可能还需要往主动方发送数据），发送完后再向主动关闭方发fin

当开启TCP延迟确认机制，且被动关闭方也没有数据需要发送的话，那么ack和fin会一起发

         





