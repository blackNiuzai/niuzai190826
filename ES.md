ES应用场景
日志采集、 全文检索

集群cluster
es是分布式的，多个节点构成的集群，具有很强的扩展性
节点
每个启动的es实例就是一个节点 可以随时加入或者脱离集群

索引（index）
将文档写入某个索引 文档=mysql的一条记录

分片（shard）
es处理的最小单元
一个分片是一个lucene索引
一个包含倒排索引的文件目录
分片越多检索越慢（过度分片造成搜索慢）

分段（segment）
lucene索引再分割的小单元
分段越多搜索越慢
分段不能被修改
索引新的文档会创建新的分段
分段会持续地被合并（像小水滴变成大水滴）
删除文档的时候不会真的删除（只是标记）



分片：扩展和容灾（索引一旦创建分片数量不能改）
一个索引的所有分片会自动均匀分布在所有节点中
加入新节点后，原集群节点的分片会部分迁移到新节点
设置分片数量稍微大于节点数量，有利于横向扩容时，分片蔓延到所有新节点（每个节点都有分片是最理想状态）
蔓延过程有消耗，所以调整节点时候会有抖动
主分片和副分片都就绪时，索引的健康状态是绿色


关于容灾
挂掉n个节点时，如果副本分片是n，剩下的副本分片自动提升为主分片，所有主分片都能构成完成的索引，仍然构成健康

如果挂掉n+1各节点，主分片缺失，健康状态红色

我们要根据实际情况设置副本数量（副本太多影响性能）
一般来说同时挂掉两个的可能性不高，一个副本即可满足常规容灾要求


es准实时： 正在写入的分段读不了，只能读关闭状态的分段
es参数默认每30秒刷新：关闭分段，执行分段合并

分片查询：等待所有分段结果


官方建议 jvm heap中每1G不超过20个分片， 每个分片大小在20-40G

实操：
字段类型映射，一般来说提前创建，可以设置mapping的template
字段类型 text和keyword， text会被分析适合全文检索， keyword不会被分析，类似mysql的精确匹配

_routing：指定文档在哪个分片


####索引、更新和删除数据
分段不能被修改，只能删除，先标记删除，刷新合并分段时候才会真删

es显然是分布式的，那么就会有并发问题
如果一个更新获取原文档进行修改期间，可能另一个更新也在修改这篇文档，那么第一个更新就丢了
ES采取文档版本号来解决这个问题（类似乐观锁）
为每一个文档设置一个版本号
文档创建时版本号是1 更新后变成2
如果此时另一个更新也在进行中，版本号也将是2，那么将产生冲突。发生冲突后会重试这个操作，如果不再冲突，那么成功，版本号更新为3
可以控制重试次数retry_on_conflict，默认为0（不重试） 可以使用挖补版本号 比如时间戳

删除文档（假删除）
可以通过id删除单个文档，也可以通过查询条件批量删除， 不推荐使用
可以DELETE my_index 删除单个索引
DELETE_all可以删除整个集群的索引


关闭索引
除了删除，我们有一个更安全的操作，就是关闭索引，不能读取和写入，直到再次打开

冻结索引（收费）
介于打开和关闭之间
不能写入，可以读，分片开销很小

reindex
可以用于重建索引

改变索引的配置
分段一旦生成就不能修改，因此索引一旦创建就无法改变
有些索引的配置也是不可改变的，比如分片数量，mapping映射等，只能通过重建索引修改

reindex不会复制索引的配置，需要提前配置，或者配置template


自动管理索引的生命周期（ILM）
可以指定策略 hot -> warm -> cold -> delete


####搜索上下文
分为查询上下文和过滤上下文
区别在于过滤器不计算相关性，只关心是否命中条件
计算相关性需要计算匹配度分值，耗费性能
匹配度分值都是实时计算，无法缓存
应该尽量使用过滤查询以减少性能消耗加快查询速度

kibana的搜索框和filter都是过滤上下文

搜索分类：
1、full-text-queries
全文检索，被查询的字段需要被分析， 查询条件也会被分析
2、term level queries:
精确匹配查询，查询条件不会被分析，通常用于结构化的数据比如数字、日期、枚举、keyword
对于被分析过的字段也可以用
3、compound-queries
嵌套查询，可以嵌套基本查询或者是另一个嵌套，比如与或非


query string 
可以指定各种 AND|OR|NOT

暴露给普通玩家 sample query string

























