## mysql的逻辑架构图

第一层：连接/线程处理、授权认证等

第二层：查询解析、分析、优化、缓存及内置函数、存储过程等

第三层： 存储引擎，负责数据的存储与提取，执行诸如“开始一个事务“、“根据主键提取一行”等，但存储引擎不会去解析SQL

### 优化与执行

mysql会解析查询，然后对其优化，包括重写查询，决定表的读取顺序以及选择合适的索引等。

对于select语句，解析查询前，会先检查查询缓存，如果命中则直接返回。

### 锁策略

所谓的锁策略，就是在锁的开销和数据的安全之间寻求平衡，这种平衡当然也会影响到性能。

锁分为共享锁和排他锁，也叫读锁和写锁

#### 表锁：

表锁是mysql中最基本的锁策略，并且是开销最小的策略

#### 行级锁：

行级锁可以最大程度地支持并发处理（同时也带来最大的锁开销）

#### innoDB处理死锁：

将持有最少行级排他锁的事务进行回滚

#### 事务日志：

事务日志可以提高事务效率， 使用事务日志时，存储引擎在修改表数据时只需要修改其内存拷贝，再把修改行为记录持久在硬盘的事务日志中，事务日志采用的是追加方式，在一小块磁盘区域内顺序I/O，然后内存中被修改的数据后台再慢慢刷回磁盘，这个日志也可以用于恢复来不及写回磁盘的数据。

#### MVCC

innoDB的MVCC是通过在每行记录后面保存两个隐藏的列实现，一个保存创建时间，一个保存过期时间或删除时间，这里的时间指的是系统版本号。

#### innoDB概览

innoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别，并且采用间隙锁策略防止幻读，使得innoDB不仅仅锁定查询涉及的行，还对索引中的间隙进行锁定，防止幻影行的插入。

## 性能剖析

#### show profile

1、set profiling = 1；

2、show profile for query #{n}

可以给出查询执行的步骤和每个步骤花费的时间

#### show status

1、flush status ; 将会话级别的计数器先置为0

2、执行查询语句；

3、show status;

## 高性能索引

#### B+Tree vs B-Tree

实际上很多存储引擎使用的是B+Tree， 即每一个叶子结点都包含指向下一个叶子结点的指针， 从而方便叶子结点的范围遍历。

B-Tree意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。

根节点的槽中存放指向子节点的指针， 而叶子节点比较特别，它的指针指向的是被索引的数据。

#### 只访问索引的查询

B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无需访问数据行。

#### 查询与排序

因为索引树中的节点是有序的，所以处理按值查询之外，索引还可以用于查询中的order by操作。一般来说，如果B-Tree可以按照某种方式查询到值，那么也可以按照这种方式用于排序。

#### InnoDB的自适应哈希索引

当innoDB注意到某些索引值被使用得非常频繁时，会在B-Tree索引之上再建立一个哈希索引。

#### 模拟哈希索引

如果需要存储大量url，并根据url进行搜索查找，如果使用B-Tree存储url，内容会非常大，因为url本身就很长，可以使用crc32做哈希，新增一列记录，查询时使用哈希索引并使用常量值进一步过滤，因为哈希会有冲突形成链表的情形。

#### 索引的优点

1、索引大大减少了服务器需要扫描的数据量。

2、索引可以帮助服务器避免排序和临时表。

3、索引可以将随机I/O变成顺序I/O。

## 高性能索引策略

#### 前缀索引

有时候需要索引很长的字符列，这会让索引变得很大且慢，一个策略是模拟哈希索引，如果列前缀选择性够高，可以使用前缀索引。

#### 多列索引

在多个列上建立独立的单列索引大部分情况下并不能提高mysql的查询性能。

#### 选择合适的索引列顺序

经验法则：在一个多列的B-Tree索引中，将选择性最高的列放到索引的最前列。这个经验有用吗？ 某些场景可能有帮助，但是通常不如避免随意I/O和排序这么重要。

当不需要考虑排序和分组时，把选择性最高的列放在前面通常是很好的。

#### 聚簇索引

优点：把相关数据保存在一起，根据id聚集数据，将索引和数据保存在一个B-Tree中，获取数据快；

缺点：

1、如果数据是在内存中，那访问顺序没那么重要，聚簇索引失去优势；

2、插入速度依赖插入顺序，按照主键顺序插入最快；

3、更新聚簇索引的列代价非常高，会强迫被更新的行移动位置；

4、插入新行或者逐渐如第三点更新主键导致需要移动行时候，会产生页分裂；

5、聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏或者页分裂引起数据存储不连续；





### B树

B树也是一种平衡的多路查找树，一棵m阶B树或为空树，或为满足一下特性的m叉树：

1、树中每个阶段至多有m棵子树；

2、若根节点不是终端节点，则至少有两个子树；

3、除根节点外的所有非也节点至少有m/2棵子树；

4、所有的叶子节点出现在同一层次上，不带信息。



#### B+树

m阶B+树与m阶B树的主要差异：

1、在B+树中，具有n个关键字的节点只含有n棵子树，而在B树中，具有n个关键字的节点含有n+1棵子树；

2、在B+树中，每个阶段（非根内部节点）关键字个树的范围不同；

3、在B+树中，叶节点包含信息，并非所有非叶节点仅起到索引作用，非叶节点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针， 不含有该关键字对应记录的存储地址；

4、在B+树中，叶节点包含了全部关键字，即在非叶节点中出现的关键字也会出现在叶节点中， 而在B树中，叶节点包含的关键字和其他节点包含的关键字是不重复的。



#### mysql为什么选择B+tree

innoDB页的大小默认值是16kb，因为B树需要把数据集或者数据集的指针存储在每一个叶子节上，这些数据占用了innoDB页大小，这样能存储的索引就比较少，造成树的层高比较高，极端情况下，IO次数比较多；

并且B+tree所有子叶节点由链表相连，便于范围查找和翻页操作。


#### 选择标识符

整数通常是最好的选择；
尽量避免使用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢；
对于完全"随机"的字符串需要多加注意，MD5(), SHA1()或者UUID()产生的字符串，新值回任意分布在很大的空间内，导致insert和一些select语句变得很慢；
但是对于一些很多写的特大表，这种伪随机值实际上可以帮助消除热点。
select变得很慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。
随机值导致缓存对所有类型的查询语句效果度很差，因为会使得缓存赖以工作的访问局部性原理失效。


#### 避免死锁
以相同的顺序加速，如果程序会并发取多个表，约定相同的顺序访问表
排序数据，程序以批量方式进行处理数据时，事先对数据排序，保证每个线程按照一样的顺序执行
在事务中如果要更新记录，直接申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能已经获得相同记录的共享锁，此时锁冲突，甚至死锁。


#### 性能参考
2.5TB SSD  CPU48核  网卡10G
TPS 3000 QPS 10000 数据库最大连接数： 20000  
最佳连接数需要测试，但最大不要超过50


### 索引值cardinality
show index from table
可以查看索引中的不重复记录，如果比较小，则要考虑这个索引有没有意义



### explain小记
####type列 访问类型
all：全表扫描
index：仅仅代表按照索引顺序扫描，并不能判断有没有扫全表，还要看有没有where和limit等
range:范围扫描
ref：也是一种索引访问，它返回所有匹配某个单独值的行
const、system：当mysql 能对查询的部分进行优化，并转换成常量的时候

####extra列
using index：表示使用了覆盖索引
using where：仅表示mysql服务器在收到存储引擎返回的记录后进行 “后过滤”
using temporary： 排序时候使用了临时表
using fileSort： 对数据使用一个外部索引排序，而不是按照表内的索引顺序进行读取。


####深分页的优化手段
子查询及延迟关联
子查询优化limit， 避免了全量回表


####通信协议
mysql客户端与服务器之间的通信协议是“半双工”的，在任何一个时刻， 要么由服务器向客户端发送数据，要么由客户端向服务器发送数据


####排序优化
无论如何，排序都是一个成本很高的操作，应尽可能避免排序或尽可能避免对大量数据进行排序，
当不能通过索引生成排序索引时，mysql需要自己排序，数据量小的时候在内存中排序，数据量大的时候需要使用磁盘，统称为fileSort
排序的数据量小于“排序缓冲区”时，mysql使用内存进行快速排序，如果内存不够排，会将数据先分块，每个独立酷爱使用快速排序并将结果放在磁盘上
，然后将各个排好的快合并


####小表驱动大表
做关联查询时候，（包括子查询 in 或者 exists）， 让语句在执行顺序上先查小表再去用小表的数据 匹配大表。


### 什么是脏页
当我们修改一条记录时，会先在缓存中修改，内存不会马上刷回磁盘，还未刷回磁盘的数据页叫脏页

### 脏页机制所以要有redo log
因为是脏页机制，可能导致的数据丢失，所以要写redo log，
redo log是追加日志，顺序写很快，如果直接写数据是随机写
但是redo log也不是直接写入磁盘，也有个redo log buffer，可以根据需要配置刷盘时机保证安全

### binlog 和 redolog
binlog用于备份恢复（全量数据） / 主从复制
redolog用户断电等故障恢复

redolog主要管主库， binlog主要影响从库的数据， 为了保证一致，mysql用了两阶段提交

####两阶段提交
需要提前了解的是：binlog在事务执行过程中也先写了binlog cache，事务提交后才写到binlog文件中

事务commit
——> innodb写redoLog, 同时将管理这两个log的事务的状态标记位prepare（这里只是先写buffer，刷盘时机由其他参数控制）
——> server层将binlog cache 写到binlog文件（这里是先写page cache，刷盘时机有其他参数控制）
——> binlog写完文件后将redo log状态设置位commit




#### 主从延迟的根本原因
从库同步时，先将binlog写入relayLog就返回了。从库再单线程回放
早期mysql为了确保从库和主库一致性，所以采用单线程回放，所以从库性能就存在了问题
后面mysql除了并行复制，所以一般情况下主从延迟比较小
一般只有大表DDL后会造成比较大的主从延迟 
即便使用了online ddl 因为主库已经完成，
逻辑角度； 原理角度不确定。
从库认为新字段可能有值的，所以从库ddl的时候会阻塞dml


####myIsam 和 innodb
写少都多的时候， myisam的性能更高
单线程的插入下，在没有什么锁竞争等待情况下，myisam写入速度更快
如果有了并发写，那innodb会占优，这是个锁粒度的问题

读取的时候，得益于指针直接指向数据，索引不需要所以myisam整体更快吧（猜测）


####b+tree 和跳表
mysql一般承载的数据量大，用跳表的话层高太高，磁盘IO多，查询性能会差点，
而redis本身是内存操作，不涉及磁盘的io, 用跳表写入操作的性能高一点（不要做树的旋转啥的）









































