## mysql的逻辑架构图

第一层：连接/线程处理、授权认证等

第二层：查询解析、分析、优化、缓存及内置函数、存储过程等

第三层： 存储引擎，负责数据的存储与提取，执行诸如“开始一个事务“、“根据主键提取一行”等，但存储引擎不会去解析SQL

### 优化与执行

mysql会解析查询，然后对其优化，包括重写查询，决定表的读取顺序以及选择合适的索引等。

对于select语句，解析查询前，会先检查查询缓存，如果命中则直接返回。

### 锁策略

所谓的锁策略，就是在锁的开销和数据的安全之间寻求平衡，这种平衡当然也会影响到性能。

锁分为共享锁和排他锁，也叫读锁和写锁

#### 表锁：

表锁是mysql中最基本的锁策略，并且是开销最小的策略

#### 行级锁：

行级锁可以最大程度地支持并发处理（同时也带来最大的锁开销）

#### innoDB处理死锁：

将持有最少行级排他锁的事务进行回滚

#### 事务日志：

事务日志可以提高事务效率， 使用事务日志时，存储引擎在修改表数据时只需要修改其内存拷贝，再把修改行为记录持久在硬盘的事务日志中，事务日志采用的是追加方式，在一小块磁盘区域内顺序I/O，然后内存中被修改的数据后台再慢慢刷回磁盘，这个日志也可以用于恢复来不及写回磁盘的数据。

#### MVCC

innoDB的MVCC是通过在每行记录后面保存两个隐藏的列实现，一个保存创建时间，一个保存过期时间或删除时间，这里的时间指的是系统版本号。

#### innoDB概览

innoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别，并且采用间隙锁策略防止幻读，使得innoDB不仅仅锁定查询涉及的行，还对索引中的间隙进行锁定，防止幻影行的插入。

## 性能剖析

#### show profile

1、set profiling = 1；

2、show profile for query #{n}

可以给出查询执行的步骤和每个步骤花费的时间

#### show status

1、flush status ; 将会话级别的计数器先置为0

2、执行查询语句；

3、show status;

## 高性能索引

#### B+Tree vs B-Tree

实际上很多存储引擎使用的是B+Tree， 即每一个叶子结点都包含指向下一个叶子结点的指针， 从而方便叶子结点的范围遍历。

B-Tree意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。

根节点的槽中存放指向子节点的指针， 而叶子节点比较特别，它的指针指向的是被索引的数据。

#### 只访问索引的查询

B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无需访问数据行。

#### 查询与排序

因为索引树中的节点是有序的，所以处理按值查询之外，索引还可以用于查询中的order by操作。一般来说，如果B-Tree可以按照某种方式查询到值，那么也可以按照这种方式用于排序。

#### InnoDB的自适应哈希索引

当innoDB注意到某些索引值被使用得非常频繁时，会在B-Tree索引之上再建立一个哈希索引。

#### 模拟哈希索引

如果需要存储大量url，并根据url进行搜索查找，如果使用B-Tree存储url，内容会非常大，因为url本身就很长，可以使用crc32做哈希，新增一列记录，查询时使用哈希索引并使用常量值进一步过滤，因为哈希会有冲突形成链表的情形。

#### 索引的优点

1、索引大大减少了服务器需要扫描的数据量。

2、索引可以帮助服务器避免排序和临时表。

3、索引可以将随机I/O变成顺序I/O。

## 高性能索引策略

#### 前缀索引

有时候需要索引很长的字符列，这会让索引变得很大且慢，一个策略是模拟哈希索引，如果列前缀选择性够高，可以使用前缀索引。

#### 多列索引

在多个列上建立独立的单列索引大部分情况下并不能提高mysql的查询性能。

#### 选择合适的索引列顺序

经验法则：在一个多列的B-Tree索引中，将选择性最高的列放到索引的最前列。这个经验有用吗？ 某些场景可能有帮助，但是通常不如避免随意I/O和排序这么重要。

当不需要考虑排序和分组时，把选择性最高的咧放在前面通常是很好的。

#### 聚簇索引

优点：把相关数据保存在一起，根据id聚集数据，将索引和数据保存在一个B-Tree中，获取数据快；

缺点：

1、如果数据是在内存中，那访问顺序没那么重要，聚簇索引失去优势；

2、插入速度依赖插入顺序，按照主键顺序插入最快；

3、更新聚簇索引的列代价非常高，会强迫被更新的行移动位置；

4、插入新行或者逐渐如第三点更新主键导致需要移动行时候，会产生页分裂；

5、聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏或者页分裂引起数据存储不连续；



