## mysql的逻辑架构图

第一层：连接/线程处理、授权认证等

第二层：查询解析、分析、优化、缓存及内置函数、存储过程等

第三层： 存储引擎，负责数据的存储与提取，执行诸如“开始一个事务“、“根据主键提取一行”等，但存储引擎不会去解析SQL

### 优化与执行

mysql会解析查询，然后对其优化，包括重写查询，决定表的读取顺序以及选择合适的索引等。

对于select语句，解析查询前，会先检查查询缓存，如果命中则直接返回。

### 锁策略

所谓的锁策略，就是在锁的开销和数据的安全之间寻求平衡，这种平衡当然也会影响到性能。

锁分为共享锁和排他锁，也叫读锁和写锁

#### 表锁：

表锁是mysql中最基本的锁策略，并且是开销最小的策略

#### 行级锁：

行级锁可以最大程度地支持并发处理（同时也带来最大的锁开销）

#### innoDB处理死锁：

将持有最少行级排他锁的事务进行回滚

#### 事务日志：

事务日志可以提高事务效率， 使用事务日志时，存储引擎在修改表数据时只需要修改其内存拷贝，再把修改行为记录持久在硬盘的事务日志中，事务日志采用的是追加方式，在一小块磁盘区域内顺序I/O，然后内存中被修改的数据后台再慢慢刷回磁盘，这个日志也可以用于恢复来不及写回磁盘的数据。

#### MVCC

innoDB的MVCC是通过在每行记录后面保存两个隐藏的列实现，一个保存创建时间，一个保存过期时间或删除时间，这里的时间指的是系统版本号。

#### innoDB概览

innoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别，并且采用间隙锁策略防止幻读，使得innoDB不仅仅锁定查询涉及的行，还对索引中的间隙进行锁定，防止幻影行的插入。

## 性能剖析

#### show profile

1、set profiling = 1；

2、show profile for query #{n}

可以给出查询执行的步骤和每个步骤花费的时间

#### show status

1、flush status ; 将会话级别的计数器先置为0

2、执行查询语句；

3、show status;

## 高性能索引

#### B+Tree vs B-Tree

实际上很多存储引擎使用的是B+Tree， 即每一个叶子结点都包含指向下一个叶子结点的指针， 从而方便叶子结点的范围遍历。

B-Tree意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。

根节点的槽中存放指向子节点的指针， 而叶子节点比较特别，它的指针指向的是被索引的数据。

#### 只访问索引的查询

B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无需访问数据行。

#### 查询与排序

因为索引树中的节点是有序的，所以处理按值查询之外，索引还可以用于查询中的order by操作。一般来说，如果B-Tree可以按照某种方式查询到值，那么也可以按照这种方式用于排序。

#### InnoDB的自适应哈希索引

当innoDB注意到某些索引值被使用得非常频繁时，会在B-Tree索引之上再建立一个哈希索引。

#### 模拟哈希索引

如果需要存储大量url，并根据url进行搜索查找，如果使用B-Tree存储url，内容会非常大，因为url本身就很长，可以使用crc32做哈希，新增一列记录，查询时使用哈希索引并使用常量值进一步过滤，因为哈希会有冲突形成链表的情形。

#### 索引的优点

1、索引大大减少了服务器需要扫描的数据量。

2、索引可以帮助服务器避免排序和临时表。

3、索引可以将随机I/O变成顺序I/O。

## 高性能索引策略

#### 前缀索引

有时候需要索引很长的字符列，这会让索引变得很大且慢，一个策略是模拟哈希索引，如果列前缀选择性够高，可以使用前缀索引。

#### 多列索引

在多个列上建立独立的单列索引大部分情况下并不能提高mysql的查询性能。

#### 选择合适的索引列顺序

经验法则：在一个多列的B-Tree索引中，将选择性最高的列放到索引的最前列。这个经验有用吗？ 某些场景可能有帮助，但是通常不如避免随意I/O和排序这么重要。

当不需要考虑排序和分组时，把选择性最高的咧放在前面通常是很好的。

#### 聚簇索引

优点：把相关数据保存在一起，根据id聚集数据，将索引和数据保存在一个B-Tree中，获取数据快；

缺点：

1、如果数据是在内存中，那访问顺序没那么重要，聚簇索引失去优势；

2、插入速度依赖插入顺序，按照主键顺序插入最快；

3、更新聚簇索引的列代价非常高，会强迫被更新的行移动位置；

4、插入新行或者逐渐如第三点更新主键导致需要移动行时候，会产生页分裂；

5、聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏或者页分裂引起数据存储不连续；





### B树

B树也是一种平衡的多路查找树，一棵m阶B树或为空树，或为满足一下特性的m叉树：

1、树中每个阶段至多有m棵子树；

2、若根节点不是终端节点，则至少有两个子树；

3、除根节点外的所有非也节点至少有m/2棵子树；

4、所有的叶子节点出现在同一层次上，不带信息。



#### B+树

m阶B+树与m阶B树的主要差异：

1、在B+树中，具有n个关键字的节点只含有n棵子树，而在B树中，具有n个关键字的节点含有n+1棵子树；

2、在B+树中，每个阶段（非根内部节点）关键字个树的范围不同；

3、在B+树中，叶节点包含信息，并非所有非叶节点仅起到索引作用，非叶节点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针， 不含有该关键字对应记录的存储地址；

4、在B+树中，叶节点包含了全部关键字，即在非叶节点中出现的关键字也会出现在叶节点中， 而在B树中，叶节点包含的关键字和其他节点包含的关键字是不重复的。



#### mysql为什么选择B+tree

innoDB页的大小默认值是16kb，因为B树需要把数据集或者数据集的指针存储在每一个叶子节上，这些数据占用了innoDB页大小，这样能存储的索引就比较少，造成树的层高比较高，极端情况下，IO次数比较多；

并且B+tree所有子叶节点由链表相连，便于范围查找和翻页操作。


#### 选择标识符

整数通常是最好的选择；
尽量避免使用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢；
对于完全"随机"的字符串需要多加注意，MD5(), SHA1()或者UUID()产生的字符串，新值回任意分布在很大的空间内，导致insert和一些select语句变得很慢；
但是对于一些很多写的特大表，这种伪随机值实际上可以帮助消除热点。
select变得很慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。
随机值导致缓存对所有类型的查询语句效果度很差，因为会使得缓存赖以工作的访问局部性原理失效。


#### 避免死锁
以相同的顺序加速，如果程序会并发取多个表，约定相同的顺序访问表
排序数据，程序以批量方式进行处理数据时，事先对数据排序，保证每个线程按照一样的顺序执行
在事务中如果要更新记录，直接申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能已经获得相同记录的共享锁，此时锁冲突，甚至死锁。


#### 性能参考
2.5TB SSD  CPU48核  网卡10G
TPS 3000 QPS 10000 数据库最大连接数： 20000  
最佳连接数需要测试，但最大不要超过50







































