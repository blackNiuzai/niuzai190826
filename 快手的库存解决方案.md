## 关于mysql和redis
一般公司mysql的可用性要优于redis，但支持的tps比较低，redis可以支持更高的tps但是数据持久性弱于mysql;


## redis主从异步复制带来的一致性问题
快手的方案是业务服务器只读主节点，从节点只用于保障可用性;


## 常规的db和redis的一致性方案
常规的数据一致性方案是采用监听mysql的binlog，来异步更新/删除缓存；
并且可以优化在写db前给缓存设置一个较短的过期时间，通过主动失效的方式防止binlog堆积造成的不一致


## 快手的db和redis的一致性方案
1、同步机制: 在更新完DB后，立即更新缓存，缓存更新失败不阻塞业务，同时发送MQ消息，消息体中含有本次缓存更新是否成功的标识
   这种方式可以保障缓存/DB基本一致

2、异步复制机制： 监听库存变更的MQ消息，如果缓存更新失败，则对缓存/DB数据进行check，如果不一致（实际上会间隔几秒，再check一次，连续3次不一致，才认为是真正的不一致）
   则进行修复。这种方式可以保障缓存/DB数据秒级延迟后变得一致

3、 定时扫描机制，前面两种方式已经可以保证正在被访问的库存/DB数据一致性。 但在存储在运行过程中，不可避免会存在主从切换，主从切换也可能会引入数据不一致，
    所以使用一个定时任务，分别从redis和db出发，进行全量扫描，双向对比，然后对发现不一致的数据进行修复。


## 快手的库存扣减
情况1：低频商品，直接更新mysql，redis监听kbus更新
情况2：大V直播秒杀品，更新redis后发送MQ，MQ消费阶段读取redis覆盖mysql （使用bufferTrigger，减少对单sku的压力）
      如何保证大V秒杀下的redis可用性呢 —— 限流保护


## ps
lua脚本并发低，尽量不要用。




